import java.util.*;
/*
 * The algorithm starts by creating a graph model using an adjacency list that represents the city
 *  through connecting objects with nodes and edges. During execution the algorithm detects all container 
 * locations through a packages array traversal process. The algorithm detects zero packages then stops
 *  evaluation because it determines no roads will be used for delivery. The algorithm executes a BFS 
 * on all locations possessing packages beginning from each individual location. 
 * The BFS method calculates traveled distance in parallel with recording the locations as visited. 
 * The algorithm confirms location visit completion for all packages following the traversal of the graph. 
 * The algorithm evaluates the minimum road count required when all packages are collected. 
 * The minimum number of roads which enables package collection while returning to the initial position is generated by the algorithm as its final output.
 */
/*
 * Code Explanation
Java utilities List Map and ArrayList are imported to make possible the collection operations.

The class named Q4B includes the main method together with a set of supporting methods.

Main Method:

Within the primary method two test examples are initiated using package locations and roads then the minRoadsToCollectPackages method calculates minimal road requirements before showing the graph display.
Graph Construction:

The minRoadsToCollectPackages method constructs the graph through a HashMap structure by making keys correspond to locations while storing a list of connected locations under each value form.
Identifying Package Locations:

During its execution the algorithm stores package location indices inside a set using a packages array traversal method.
BFS Implementation:

An algorithm performs BFS using a queue to explore the graph starting from every location that contains a package. During execution it records present spot along with total traveled meters.
Checking Package Collection:

The algorithm performs an examination of all visited package locations during the BFS processing. It records the minimum road count if all locations with packages receive a visit.
Returning Result:

The method determines the exact number of roads essential for obtaining all packages while returning to the original location.
Graph Printing:

The printGraph method creates and displays the graph format that shows location connection information.
 */
public class Q4B {
    public static void main(String[] args) {
        // Test case 1
        int[] packages1 = {1, 0, 0, 0, 0, 1};
        int[][] roads1 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}};
        System.out.println("Minimum roads to traverse: " + minRoadsToCollectPackages(packages1, roads1)); // Output: 2
        printGraph(roads1);

        // Test case 2
        int[] packages2 = {0, 0, 0, 1, 1, 0, 0, 1};
        int[][] roads2 = {{0, 1}, {0, 2}, {1, 3}, {1, 4}, {2, 5}, {5, 6}, {5, 7}};
        System.out.println("Minimum roads to traverse: " + minRoadsToCollectPackages(packages2, roads2)); // Output: 2
        printGraph(roads2);
    }

    public static int minRoadsToCollectPackages(int[] packages, int[][] roads) {
        // Build the graph
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] road : roads) {
            graph.putIfAbsent(road[0], new ArrayList<>());
            graph.putIfAbsent(road[1], new ArrayList<>());
            graph.get(road[0]).add(road[1]);
            graph.get(road[1]).add(road[0]);
        }

        // Find all locations with packages
        Set<Integer> locationsWithPackages = new HashSet<>();
        for (int i = 0; i < packages.length; i++) {
            if (packages[i] == 1) {
                locationsWithPackages.add(i);
            }
        }

        // If there are no packages, no roads need to be traversed
        if (locationsWithPackages.isEmpty()) {
            return 0;
        }

        // Perform BFS to find the minimum roads to collect all packages
        int minRoads = Integer.MAX_VALUE;
        for (int start : locationsWithPackages) {
            boolean[] visited = new boolean[packages.length];
            Queue<int[]> queue = new LinkedList<>();
            queue.offer(new int[]{start, 0}); // {current location, distance}
            visited[start] = true;

            while (!queue.isEmpty()) {
                int[] current = queue.poll();
                int currentLocation = current[0];
                int currentDistance = current[1];

                // Collect packages within distance 2
                for (int neighbor : graph.get(currentLocation)) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        queue.offer(new int[]{neighbor, currentDistance + 1});
                    }
                }

                // Check if all packages are collected
                if (allPackagesCollected(visited, locationsWithPackages)) {
                    minRoads = Math.min(minRoads, currentDistance);
                }
            }
        }

        return minRoads;
    }

    private static boolean allPackagesCollected(boolean[] visited, Set<Integer> locationsWithPackages) {
        for (int location : locationsWithPackages) {
            if (!visited[location]) {
                return false;
            }
        }
        return true;
    }

    // Method to print the graph
    private static void printGraph(int[][] roads) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] road : roads) {
            graph.putIfAbsent(road[0], new ArrayList<>());
            graph.putIfAbsent(road[1], new ArrayList<>());
            graph.get(road[0]).add(road[1]);
            graph.get(road[1]).add(road[0]);
        }

        System.out.println("Graph representation:");
        for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {
            System.out.println("Location " + entry.getKey() + " is connected to: " + entry.getValue());
        }
    }
}